<html>

<head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <style type="text/css">
        @import url('https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap');

        .c6 {
            -webkit-text-decoration-skip: none;
            color: #000000;
            font-weight: 400;
            text-decoration: underline;
            vertical-align: baseline;
            text-decoration-skip-ink: none;
            font-size: 11pt;
            font-family: "Source Sans Pro", sans-serif;
            font-style: italic
        }

        .c10 {
            padding-top: 0pt;
            padding-bottom: 12pt;
            line-height: 1.0;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        .c15 {
            color: #000000;
            font-weight: 700;
            text-decoration: none;
            vertical-align: baseline;
            font-size: 11pt;
            font-family: "Source Sans Pro", sans-serif;
            font-style: normal
        }

        .c5 {
            color: #000000;
            font-weight: 400;
            text-decoration: none;
            vertical-align: baseline;
            font-size: 11pt;
            font-family: "Courier New";
            font-style: normal
        }

        .c16 {
            -webkit-text-decoration-skip: none;
            color: #000000;
            text-decoration: underline;
            vertical-align: baseline;
            text-decoration-skip-ink: none;
            font-style: normal
        }

        .c9 {
            font-size: 11pt;
            font-family: "Source Sans Pro", sans-serif;
            font-weight: 400
        }

        .c11 {
            color: inherit;
            text-decoration: inherit
        }

        .c17 {
            margin-left: 36pt
        }

/*********************************************************************/

        ol {
            margin: 0;
            padding: 0
        }

        table td,
        table th {
            padding: 0
        }

        /*.c1*/ .c3 {
            color: #000000;
            font-weight: 400;
            text-decoration: none;
            vertical-align: baseline;
            font-size: 14pt;
            font-family: "Source Sans Pro", sans-serif;
            font-style: italic
        }

        /*.c6 {
            color: #000000;
            font-weight: 400;
            text-decoration: none;
            vertical-align: baseline;
            font-size: 12pt;
            font-family: "Source Sans Pro", sans-serif;
            font-style: normal
        }*/

        /*.c9*/ .c7 {
            color: #000000;
            font-weight: 600;
            text-decoration: none;
            vertical-align: baseline;
            font-size: 11pt;
            font-family: "Source Sans Pro", sans-serif;
            font-style: normal;
        }

        /*.c7*/ .c13 {
            color: #000000;
            font-weight: 400;
            text-decoration: none;
            vertical-align: baseline;
            font-size: 12pt;
            font-family: "Times New Roman";
            font-style: normal
        }

        /*.c4*/ .c1 {
            color: #000000;
            font-weight: 400;
            text-decoration: none;
            vertical-align: baseline;
            font-size: 14pt;
            font-family: "Source Sans Pro", sans-serif;
            font-style: normal
        }

        /*.c5*/ .c4 {
            color: #000000;
            font-weight: 700;
            text-decoration: none;
            vertical-align: baseline;
            font-size: 20pt;
            font-family: "Source Sans Pro", sans-serif;
            font-style: normal
        }

        /*.c10*/ .c12 {
            color: #000000;
            font-weight: 700;
            text-decoration: none;
            vertical-align: baseline;
            font-size: 26pt;
            font-family: "Source Sans Pro", sans-serif;
            font-style: normal
        }

        .c0 {
            padding-top: 0pt;
            padding-bottom: 12pt;
            line-height: 1.5;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        /*.c2*/ .c8 {
            padding-top: 0pt;
            padding-bottom: 10pt;
            line-height: 1.0;
            orphans: 2;
            widows: 2;
            text-align: center
        }

        /*.c11*/ .c14 {
            padding-top: 0pt;
            padding-bottom: 0pt;
            line-height: 1.0;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        /*.c12*/ .c18 {
            background-color: #ffffff;
            max-width: 600pt;
            margin-left: auto;
            margin-right: auto;
        }

        ._c3 {
            height: 12pt
        }

        /*.c8*/ .c2 {
            page-break-after: avoid
        }

        .title {
            padding-top: 24pt;
            color: #000000;
            font-weight: 700;
            font-size: 36pt;
            padding-bottom: 6pt;
            font-family: "Times New Roman";
            line-height: 1.0;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        .subtitle {
            padding-top: 18pt;
            color: #666666;
            font-size: 24pt;
            padding-bottom: 4pt;
            font-family: "Georgia";
            line-height: 1.0;
            page-break-after: avoid;
            font-style: italic;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        li {
            color: #000000;
            font-size: 12pt;
            font-family: "Times New Roman"
        }

        p {
            margin: 0;
            color: #000000;
            font-size: 12pt;
            font-family: "Times New Roman"
        }

        h1 {
            padding-top: 24pt;
            color: #000000;
            font-weight: 700;
            font-size: 24pt;
            padding-bottom: 6pt;
            font-family: "Times New Roman";
            line-height: 1.0;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        h2 {
            padding-top: 0pt;
            color: #000000;
            font-weight: 700;
            font-size: 22pt;
            padding-bottom: 0pt;
            font-family: "Source Sans Pro", sans-serif;
            line-height: 1.0;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        h3 {
            padding-top: 14pt;
            color: #000000;
            font-weight: 700;
            font-size: 14pt;
            padding-bottom: 4pt;
            font-family: "Times New Roman";
            line-height: 1.0;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        h4 {
            padding-top: 12pt;
            color: #000000;
            font-weight: 700;
            font-size: 12pt;
            padding-bottom: 2pt;
            font-family: "Times New Roman";
            line-height: 1.0;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        h5 {
            padding-top: 11pt;
            color: #000000;
            font-weight: 700;
            font-size: 14pt;
            padding-bottom: 2pt;
            font-family: "Times New Roman";
            line-height: 1.0;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }

        h6 {
            padding-top: 10pt;
            color: #000000;
            font-weight: 700;
            font-size: 10pt;
            padding-bottom: 2pt;
            font-family: "Times New Roman";
            line-height: 1.0;
            page-break-after: avoid;
            orphans: 2;
            widows: 2;
            text-align: left
        }
    </style>
    <title>Designing a programmable sound generator board, part 2</title>
    <meta name="og:title" content="Designing a programmable sound generator board, part 2">
    <meta name="og:image" content="https://mcjack123.github.io/PSG/part-2/images/image6.jpg">
    <meta name="og:description" content="I designed, programmed, and built my own 8-bit programmable sound generator/synthesizer using a few cheap microcontrollers and a Raspberry Pi Pico.">
</head>

<body class="c18 doc-content">
    <div>
        <p class="_c3 c14"><span class="c13"></span></p>
    </div>
    <p class="c10"><span class="c12">Designing a programmable sound generator board, part 2</span></p>
    <p class="c0"><span class="c3">If you haven&#39;t read the </span><span class="c6"><a class="c11"
                href="http://mcjack123.github.io/PSG/">first
                part</a></span><span class="c3">, where I introduce the idea and architecture, I highly recommend
            reading it before continuing.</span></p>
    <p class="c0"><span class="c1">Since making the first prototype of my PSG, I didn&#39;t make any changes to the
            board, or even use it much at all. I was completely burned out after the 12 hour soldering session, and I
            did </span><span class="c3">not</span><span class="c1">&nbsp;want to have to do it again (even if I now knew
            how to speed it up a bit). Furthermore, I knew that at some point I&#39;d eventually get a proper circuit
            board printed, and all work on the prototype would be obsolete after that happened. Finally, the wires I had
            connected to the Pico were very fragile, unprotected, and not organized in a way that would let me pull the
            Pico out cleanly. These all combined with the fact that I had other more important things to do during the
            summer (like finishing </span><span class="c9 c16"><a class="c11"
                href="https://phoenix.madefor.cc">Phoenix</a></span><span
            class="c1">), which meant that I had no time to make any progress.</span></p>
    <p class="c0"><span class="c1">Even though I had a PCB prototype designed, I avoided actually getting it printed for
            a long time. This is because the board I designed was four layers deep. I did this because I believed that
            it was not possible to connect all the traces to all 18 chips using only two layers. The manufacturer I
            wanted to use, JLCPCB, wanted $40 for a set of 5 boards, and this was a bit too much for me at the time, so
            I didn&#39;t get the board printed.</span></p>
    <p class="c0"><span class="c1">In addition, this summer has been my busiest yet, as I was preparing to move to
            college, which meant putting away tons of parts, tools, and wires, and just generally cleaning up ahead of
            my departure. Once I moved out, I had very few electronic parts with me - I only had the Arduino I used as
            an adapter for my keyboard, and the Raspberry Pi I used to build packages for ARM Linux. This kept the
            project out of my head, as I wasn&#39;t fiddling with electronics for hours anymore.</span></p>
    <h2 class="c2"><span class="c4">Rebooting the project</span></h2>
    <p class="c0"><span class="c1">However, this all changed around the beginning of October. &nbsp;One day, I was
            walking around, stretching my legs after being </span><span class="c9">at</span><span class="c1">&nbsp;my
            desk for hours, and a random thought popped into my head.</span></p>
    <p class="c0 c17"><span class="c3">Why did I put the frequency multiplication code on the slow, time-sensitive PIC
            chips, and not on the fast, time-insensitive Pico?</span></p>
    <p class="c0"><span class="c1">This thought possessed my mind for the rest of the day. </span><span class="c3">Wow,
            that was really a stupid move. I&#39;ve gotta fix that - it&#39;ll make my code </span><span
            class="c1">so</span><span class="c3">&nbsp;much better.</span><span class="c1">&nbsp;As soon as I had a
            moment, I opened up the assembly code for the first time in many months, and adjusted the code to save the
            input directly instead of running the multiplication. Then I updated the Pico&#39;s code to move the
            multiplication there, making it send the precomputed increment instead of the frequency.</span></p>
    <p class="c0"><span class="c1">Unfortunately, I did not have the board with me to test with. So, as any normal
            person would, I decided to write an entire emulator for the processor. Two days and 1000 lines of C code
            later, I had a working emulator that could load the hex files that the compiler output, and I was able to
            verify (mostly) that the code worked properly.</span></p>
    <p class="c0"><span class="c1">Meanwhile, I wanted to revisit my PCB design to see if there were any optimizations I
            could make. In particular, I wanted to adjust it so that a) there were full ground and V+ planes on the
            surfaces, b) the interrupt and Pico signal traces were on their own separate layers (previously, they were
            mixed across layers), and c) the traces were just generally cleaner. I started to work on it a bit, but
            eventually I realized that I needed to remap all of the pins and traces to use &quot;nets&quot; (groups of
            pins that all connect together) if I wanted to have proper planes. To fix this, I rewired the entire board,
            mapping all 288 pins to the required nets before placing the traces. Then I placed some rectangles to create
            the ground and V+ planes, and filled them in, which now worked correctly, avoiding all traces except for the
            ones they were connected to.</span></p>
    <p class="c0"><span class="c1">Once that redesign was done, I checked the price of the PCB again just in case
            something changed, but it was still $40. At that point, I figured that the price was likely due to the fact
            that I was still using a four-layer board. I continued redesigning the board by removing the middle two
            layers, instead trying to route the middle traces across the horizontal bus traces on both layers. I had
            been avoiding this both for simplicity of design and because I was afraid of using too many vias (not quite
            sure why), but after a few hours of rewiring I had a fully connected two-layer board. I uploaded this
            version to the PCB website, and discovered that the board was only $5! At that point, I decided it was worth
            it to finally build the full circuit board.</span></p>
    <p class="c0"><span class="c1">Because I already had most of the chips I needed, I only bought eight more PIC chips
            to complete the set of 16 alongside the eight I had from the prototype. I also needed an extra shift
            register chip for those eight chips. However, I couldn&#39;t reuse any of the sockets from the prototype, so
            I bought all new sockets for those. Finally, I got some female pin headers for the Pi Pico to slot into,
            instead of relying on loose wires as the prototype did. The total price for all those parts was about $30 -
            if I&#39;d bought all of the parts required, it would come out to about $45.</span></p>
    <p class="c0"><span class="c1">Before ordering everything, I checked over the board multiple times to really make
            sure that I had everything right. I adjusted some of the traces to be a bit more clean, and also changed the
            color of the board from standard green to a nice purple that both looked great and had very visible traces.
            Once everything was checked over and complete, I placed the order, and waited for the board to arrive -
            estimates from the manufacturer said about 3 days for production, plus 2-4 weeks for delivery.</span></p>
    <p class="c8"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 467.86px; height: 213.28px;"><img
                alt="IMG_0305.png" src="images/image4.png"
                style="width: 471.18px; height: 213.28px; margin-left: -1.66px; margin-top: -0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c8"><span class="c7">The PCB schematic as I sent it for production.</span></p>
    <h2 class="c2"><span class="c4">Rewriting the software</span></h2>
    <p class="c0"><span class="c1">While I waited, I went back to the software to see if there were any major things I
            could do to optimize it. One big concern I remembered from the initial design was that I had a lot of
            trouble relating to transfer speeds. When I tried to play some 8- or 16-channel modules in tracc, I
            experienced a lot of slowdown issues on particularly heavy rows. These modules never gave me any issues when
            played using the native sound plugin, or even with software sample-based playback. I discovered that a
            potential bottleneck for transfer speeds was likely in the speed of the USB serial protocol. Even when I
            changed the baud rate of the port to different speeds, it was still stuck running much slower than I needed.
            I had tried using different methods to try to batch the data transferred, but nothing managed to work quite
            well enough, and it only made my code much messier than it needed to be.</span></p>
    <p class="c0"><span class="c1">To try to solve this issue, I first looked at writing my own USB protocol to transfer
            the data. I poked around at using libusb and TinyUSB (the Pi Pico SDK&#39;s built-in USB stack) to send data
            using the same protocol I was using over serial, but directly. However, I eventually came to a realization
            that there was likely a protocol that already existed with enough features for me to be able to use. Then it
            hit me &ndash; that protocol I was looking for was MIDI, which is specifically intended for musical
            instruments, and has plenty of commands to be able to not only directly control the PSG&#39;s parameters,
            but also add effects to the music and other system controls. Another really cool benefit was that it could
            become an actual synthesizer device, able to play back MIDI files and be plugged into digital audio
            workstations like Garageband. This sounded really cool to me, and I got to work rewriting my entire Pico
            driver around the MIDI protocol.</span></p>
    <p class="c0"><span class="c1">Up to this point, I&#39;d rarely used TinyUSB directly on the Pico. My only
            experience was through the USB standard I/O package that the Pico SDK added to be able to use C printf and
            other functions to send serial data. I&#39;d also once tried to use the host stack to allow using a keyboard
            with the Pico, but I never got it to work properly. In addition, TinyUSB didn&#39;t have much documentation
            at all about how to use it or what functions it provided, so I had to copy from the examples and try to
            piece together what they did.</span></p>
    <p class="c0"><span class="c1">TinyUSB&#39;s MIDI support consists of a few functions to read and write MIDI
            messages, as well as some callback functions for when packets are received + device connect/disconnect
            notifications. For the first version, I avoided using any of the callbacks and instead opted to run
            everything in the main loop. The loop would run the TinyUSB device task to fetch packets, and then for each
            packet received it decoded them and then executed the instructions directly. One issue I ran into real quick
            is that the message reading function didn&#39;t have any indication as to how the data was stored - it just
            wanted a four-byte buffer - so I assumed it was a normal MIDI message, with the first byte being the status,
            and the other two were parameters. To clean it up, I made a four-byte structure that named each byte with
            what it did. But when I started testing it, the commands were giving me random data. After throwing it in a
            debugger, I discovered that the actual message started on the </span><span class="c3">second</span><span
            class="c1">&nbsp;byte - the first byte appeared to be junk, so I moved the junk byte four up to the first
            byte instead, shifting the names down by one. (After reading the USB MIDI protocol standard, I discovered
            that this byte was a special indicator that held some metadata to help players. This byte stored information
            such as the &quot;cable number&quot;, which allows more than 16 channels on one cable, and whether the
            stream contained a SysEx command.)</span></p>
    <p class="c0"><span class="c1">The command parser was very simple: it used a bunch of switch/case statements to
            select how to modify the playback. The main statement switched over the primary status command, which was
            the first four bits of the status byte. To make the board at least base-level compatible with MIDI, I
            implemented all of the commands properly, including note on/off, pitch bend, aftertouch, program change, and
            as many control change settings as I could. I also added some features to be able to control the board with
            direct commands to the PSG components, which included direct frequency and volume adjustment control change
            wheels for each channel. Since the chips could only play one note at a time, while MIDI could play multiple
            notes at once, I needed to have some code to automatically reassign channels when multiple notes are being
            played. I also implemented a mode change to be able to swap the synthesizer code between MIDI mode (which
            can play multiple notes per channel &amp; reassigns chips as needed) and PSG mode (which has exactly one
            chip per channel, so one note per channel). Luckily, MIDI already had a monophony/polyphony switch assigned
            to two control change wheels, so I used those to control which mode the board was in.</span></p>
    <p class="c0"><span class="c1">On the PC side, I also rewrote the CraftOS-PC plugin to use MIDI instead of serial.
            This involved learning how to use the PortMidi library, which is a simple cross-platform API for interacting
            with MIDI devices. I adjusted the functions to send MIDI events instead of using my custom serial protocol,
            which appeared to work from just reading it over, but I knew that </span><span class="c3">some</span><span
            class="c1">&nbsp;issue would pop up once I was able to test it on the real device.</span></p>
    <p class="c8"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 438.18px; height: 328.64px;"><img
                alt="IMG_5091.jpeg" src="images/image2.jpg"
                style="width: 438.18px; height: 328.64px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c8"><span class="c7">The circuit boards, bare and unpopulated (mostly).</span></p>
    <h2 class="c2"><span class="c4">Assembling the new board</span></h2>
    <p class="c0"><span class="c1">By the time I finished writing the first MIDI code, the boards arrived from China
            &ndash; they were at my doorstep in just over a week, which was </span><span class="c3">way</span><span
            class="c1">&nbsp;faster than I expected. I&#39;d already received the other parts I needed </span><span
            class="c9">during</span><span class="c1">&nbsp;that time, so everything was ready to go. After taking a few
            hours to inspect the boards and just generally </span><span class="c9">feeling</span><span
            class="c1">&nbsp;happy about finally getting my own boards fabricated, I scheduled an appointment with the
            local Makerspace&#39;s soldering iron, and got the stuff I needed together in preparation.</span></p>
    <p class="c0"><span class="c1">I went into the Makerspace with a backpack full of all of the parts I needed,
            including the PCB, the sockets, the chips, and my Pico and prototype board, which I had just picked up from
            home the day before. I sat down at the soldering station, and proceeded to unpack all of my materials before
            starting. I started by attaching the sockets for each chip - 19 sockets in total, with 264 pins to solder.
            It took me about half an hour to get through all of those pins, and, once the board was heated up a bit,
            each joint went together as smooth as butter. After that, I added the header for the Pico - 40 pins combined
            - and that went pretty well; though I did end up with one of the headers at an angle, so I had to use a bit
            of force to bend it to fit.</span></p>
    <p class="c0"><span class="c1">Then I moved onto the headphone jack. I had very few of these, and I wanted to reuse
            the one I had on the prototype to avoid having to find more. It also happened to be one of the only jacks
            that had a footprint built into the PCB designer. So first, I had to desolder the port from the old board.
            At first, I thought this wouldn&#39;t be too hard, but after a few minutes of attempts, I was unable to get
            all of the solder out of the hole. I did have both solder suckers and wick at my disposal, but neither of
            these were effective enough to get all of the solder out. After over half an hour of trying to get it out, I
            eventually managed to just barely rip it out of the board, though there were pads from the breadboard still
            stuck on some of the pins. I figured this wouldn&#39;t be much of an issue, but as soon as I tried to push
            the jack into the board, one of the pins inside the jack bent way out of shape. I tried to helplessly get it
            to go back to normal, but after much more struggling, it eventually became unsalvageable, and I just ripped
            the entire thing out in search of a new solution. Luckily, there happened to be a piezoelectric beeper in
            the spare parts bin next to me, and I made a split-second decision to add that instead. (Little did I know
            that that decision would be a serious problem in the future.)</span>
        <hr style="page-break-before:always;display:none;">
    </p>
    <p class="c0"><span class="c1">Fortunately, I managed to get the potentiometer for volume control off of the
            original board (with a tiny last-minute hack after I tore one of the traces off of the pot&#39;s carrier
            board), and I added that on last. Once it was all together, I hastily added the chips onto the board,
            plugged in the Pico, and tried to test it out. I didn&#39;t have my development PC with me, so I was only
            able to test out the MIDI functionality, but I was unable to get any sound out of it. Because I was already
            running over an hour over my appointment time, and I didn&#39;t have enough stuff with me to properly debug
            it, I collected the assembled board and leftover parts, and headed back home to do further
            testing.</span></p>
    <p class="c8"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 456.33px; height: 342.24px;"><img
                alt="IMG_5095.jpeg" src="images/image5.jpg"
                style="width: 456.33px; height: 342.24px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c8"><span class="c7">The assembled board with all chips socketed.</span></p>
    <h2 class="c2"><span class="c4">Analyzing the broken output</span></h2>
    <p class="c0"><span class="c1">I was expecting the debugging process to be a bit of a pain, but I completely
            underestimated how much pain I was about to go through. The first issue I had to wrangle with was a complete
            lack of output. At first, I thought it was an issue with the MIDI code, but I kept tweaking it and trying to
            find issues, but I didn&#39;t find any. To </span><span class="c3">really</span><span class="c1">&nbsp;make
            sure it wasn&#39;t a MIDI issue, I completely restructured the code to send commands differently - instead
            of actively looking for MIDI packets in the main loop, I moved to using the callback functions that TinyUSB
            provides. After that change, the main loop was simply calling the TinyUSB update task infinitely. I also
            moved the output code into its own loop on the second core, which allowed me to batch commands effectively,
            as well as run effects like volume release/fade out (though this wasn&#39;t implemented until much
            later).</span></p>
    <p class="c0"><span class="c1">Even with this change, I couldn&#39;t hear anything at all. As a last resort, I
            decided to wire up a speaker cable instead of using the beeper, and turned up the volume on my speaker to
            maximum to see if it was too quiet for the beeper. </span><span class="c3">Well.</span><span
            class="c1">&nbsp;It turned out that it </span><span class="c3">was</span><span class="c1">&nbsp;working, but
            the output was just extremely quiet. I was a bit confused about it, but figured it was likely a result of me
            not wiring the op amp correctly. To confirm that, I tried removing the op amp. Just a few weeks before, I
            learned in one of my college classes that the op amp was actually unnecessary to combine the signals - the
            linearity property of electrical circuits causes parallel voltage sources to add together, which is exactly
            what I&#39;m dealing with. However, adding 16 voltage sources that go up to 3.3V (1.6V when silent) could
            reach voltages in excess of 50V! This is not safe for audio equipment at all. The op amp&#39;s function was
            also to reduce the voltage to a safe level for audio equipment. Pulling out the main component that was
            limiting the voltage was a bit scary, but I did it anyway.</span></p>
    <p class="c0"><span class="c1">It turned out the potentiometer I used for tuning the op amp had the perfect
            resistance to drop the voltage to a decent level, and I got an (ear-bustingly loud) wave to output from the
            speaker, though the wave was still too quiet for the beeper. However, it sounded really odd - my square wave
            was super noisy, my sine wave sounded like a terrible triangle wave, and my triangle wave was just blips. I
            was really confused as to why this was happening, so I plugged it into my PC to try to see the output
            waveform through Audacity. I discovered that the waveforms were </span><span
            class="c3">massively</span><span class="c1">&nbsp;distorted for some reason.</span></p>
    <p class="c8"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 328.75px; height: 308.25px;"><img
                alt="IMG_0303.png" src="images/image1.png"
                style="width: 328.75px; height: 308.25px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c8"><span class="c7">The waveforms I was getting. From top to bottom: sawtooth up, sawtooth down, square
            (50%), triangle, sine.</span></p>
    <p class="c0"><span class="c1">To try to analyze this issue, I went to my college&#39;s engineering lab to analyze
            the inputs and outputs using an oscilloscope. After setting up the workstation - the oscilloscope was over
            20 years old and ran Windows 98! - I started probing around to try to find the voltages. But the scope was
            very uncalibrated, giving me wildly inaccurate measurements, and I had no idea how to work the thing -
            I&#39;d never used an oscilloscope before this, and I was especially inexperienced with scopes that ran
            Windows and used a keyboard and mouse to configure settings. After some poking around, I was able to find
            the calibration menu, and I was able to get it measuring my circuit properly.</span></p>
    <p class="c0"><span class="c1">I first checked the voltage of the initial output rail connected to all of the chips,
            and confirmed that it was outputting about 25V when silent. I also found that the waveform was correct! I
            then checked the voltage coming out of the op amp, and found that not only was the output ridiculously low,
            it also had the same weird shapes. Eventually, I had a realization: </span><span class="c3">the beeper
            module I added was acting as a capacitor, and was affecting the shape of the speaker cable
            output.</span><span class="c1">&nbsp;This is (probably) because the piezoelectric component is made with two
            electrodes that have a piezoelectric </span><span class="c15">insulating</span><span
            class="c1">&nbsp;material between them, which is how a capacitor is constructed. Adding a voltage output in
            parallel was taking the voltage across the beeper, which, as I learned later on in the college class, was
            equal to the integral of the current. This ended up affecting the shape pretty badly.</span></p>
    <p class="c0"><span class="c3">Note: Ok, I&#39;ll admit that I&#39;m not entirely sure the exact reason why the
            shape was affected - the characteristics of the beeper are still a bit of a mystery to me, and I&#39;m not
            quite 100% solid on the class material yet. However, the appearance of derivatives in the waveforms does
            appear to line up with my theory - it&#39;s just a bit hazy how exactly they connect together, especially as
            derivative voltages are more consistent with inductors... which would match with a normal speaker
            instead.</span></p>
    <p class="c0"><span class="c1">To resolve the issue, I cut the trace connecting the speaker, and tested it out. Lo
            and behold, the output sounded great. After fiddling with a few more things, and putting all of the chips
            back in (as I had been testing with only one at a time), I tried it out with an 8-channel module. Besides
            some volume inconsistencies, it was beautiful.</span></p>
    <p class="c8"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 405.97px; height: 304.48px;"><img
                alt="IMG_5103.jpeg" src="images/image3.jpg"
                style="width: 405.97px; height: 304.48px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c8"><span class="c7">My oscilloscope workstation while playing the 8-channel module.</span></p>
    <h2 class="c2"><span class="c4">Finishing touches</span></h2>
    <p class="c0"><span class="c1">At this point, the board was working well enough for many songs to play. However, I
            was still facing a number of minor issues that caused glitches in the audio. First of all, the sine waves
            sounded much louder than the rest of the wave types when playing some of my songs. Normally, pure sine waves
            sound quieter than other sharper wave types, so I account for that by boosting the volume of the sine
            instruments. However, for whatever reason the sine wave was about as loud as the other waves, so it was
            overpowering everything else in the song. It also sounded like the loudness increased much quicker towards
            the higher volume levels. To fix this, I implemented a logarithmic equation to make the volume increase
            slower as it goes higher. This solved my volume scaling issues, though it did make volume jumps from 0 to 1
            much more noticeable.</span></p>
    <p class="c0"><span class="c1">The other issue I was facing was much more serious than the volume glitch. Very
            occasionally, some songs would completely miss some notes or effects. These misses were always in the exact
            same location, but I couldn&#39;t figure out what pattern the misses were happening in. I spent multiple
            days scouring my code to figure out what the cause could be - I rewrote the code a few times, added various
            pauses in case it was a timing issue, and even ripped out all of the chips to test each channel one-by-one.
            After nearly a week of squeezing my brain into paste to find the bug, I finally found the reason:
        </span><span class="c3">I never cleared the chip selector after sending a command.</span><span
            class="c1">&nbsp;This meant that when two commands were sent to the same chip without any other chips being
            updated, the wire that tells the chip that a new command didn&#39;t pulse - it just stayed on as it was
            before, and thus the chip never went into command selection mode. To fix this, all I had to do was tell the
            shift register to update its output after clearing the memory, which actually reset all of the pins to zero,
            letting new signals generate pulses again. Once this bug was fixed, the board sounded perfectly as I wanted
            it to.</span></p>
    <p class="c0"><span class="c1">But I wasn&#39;t done coding yet.</span></p>
    <p class="c0"><span class="c1">Having to rip out each and every chip to reprogram them was getting pretty annoying -
            it took at least 5 minutes and around 10 bent pins each time to do one reprogramming cycle. I was getting
            fed up with this labor-intensive process - I&#39;d only been programming four chips at a time while testing
            to avoid having to rip out all the others. I wanted to add an In-Circuit Serial Programming (ICSP) port to
            my board to make this easier; however, ICSP is a two-way protocol, and having every pin of each chip
            connected together would cause interference (and high voltages!) while every chip sends its own signals out.
            I wanted to find an alternative to ICSP that would allow me to send one-way firmware data to every chip at
            the same time.</span></p>
    <p class="c0"><span class="c1">While searching, I came across an article talking about programming microcontrollers,
            and in it they mentioned that people usually program their chips with a bootloader first, which then handles
            writing the code to memory from a more convenient location. </span><span class="c3">Duh! I could write my
            own bootloader using the same 8-bit bus connected to the Pico!</span><span class="c1">&nbsp;I started
            reading the documentation for writing to the flash code memory on the PIC, and after a few hours I had a
            basic bootloader (written in assembly) that could accept HEX-formatted firmware from the 8-bit bus and write
            it to the flash. To send the data, I added a SysEx command on the Pico&#39;s MIDI interface that takes a
            whole HEX file, adjusts it into a consistent format for sending to the PIC chips, and then selects
        </span><span class="c3">every</span><span class="c1">&nbsp;chip at once and sends an </span><span class="c5">FF
            01</span><span class="c1">&nbsp;command with the firmware data.</span></p>
    <p class="c0"><span class="c1">After adding the firmware update command, I wanted to streamline uploading firmware
            updates to the device. To do this, I wrote a simple updater script that can update the PIC, the Pico, or
            both together. It worked by either loading HEX data and sending the SysEx command over MIDI, or loading a
            UF2 binary and sending another command to the Pico to tell it to flip into its own bootloader mode, after
            which the updater copied the UF2 onto the Pico through the standard USB drive interface it provides. To be
            able to update both at the same time, I created a file format that is a simple concatenation of the PIC HEX
            and the Pico UF2 files into one. The updater could then first load and upload the HEX data, and then load
            and upload the UF2 binary from the same file. With this, reprogramming the entire board was as simple as a
            single command, </span><span class="c5">programmer firmware.bin</span><span class="c1">. Packaging the
            firmware is also easy - a simple </span><span class="c5">cat PSG.X.production.hex sound.uf2 &gt;
            firmware.bin</span><span class="c1">&nbsp;command is all it takes.</span></p>
    <p class="c8"><span
            style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 511.81px; height: 298.33px;"><img
                alt="IMG_5222.jpeg" src="images/image6.jpg"
                style="width: 511.81px; height: 298.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);"
                title=""></span></p>
    <p class="c8"><span class="c7">The complete final board.</span></p>
    <p class="c10"><span class="c12">Conclusion &amp; Future</span></p>
    <p class="c0"><span class="c1">I&#39;ve had a lot of fun building this board so far, and I&#39;m proud of the
            results that I&#39;ve been able to produce. Having a physical board that makes these sounds feels so much
            more authentic than replicating it in a basic program, even if it&#39;s still digitally generated and not a
            true analog synth. And being able to play all sorts of music &ndash; including sounds in emulated 8-bit
            console games &ndash; without any issues is awesome to have working so well. Being able to play MIDI files
            has also been pretty cool to test out - Windows </span><span class="c5">canyon.mid</span><span
            class="c1">&nbsp;is surprisingly pleasant when played with chiptune waves.</span></p>
    <p class="c0"><span class="c1">While writing this document (essay? paper? write-up?), I&#39;ve started investigating
            more complex synthesis types. My first step is likely going to involve adding some filter options to the
            basic waves, as analog synthesizers do. This&#39;ll involve adding various types of multiplication,
            which&#39;ll take up lots more CPU time, but luckily the current code only uses about 10% of the time if I
            want to keep it above a 48kHz sample rate, so I have plenty of headroom to add more code. I&#39;ll also need
            to adjust the command format to allow for more controls beyond wave type/volume/frequency, which should be
            pretty simple, but I want to keep the data transfer size low to avoid wasting cycles.</span></p>
    <p class="c0"><span class="c1">I&#39;ve also been investigating implementing FM synthesis... or rather, PM (pulse
            modulation) synthesis; the same type that&#39;s used on synthesizers like the Yamaha DX7. I&#39;ve learned a
            lot about FM synthesis, and I&#39;m even working on a software DX7 simulator to learn more about how it
            works. Implementing it involves simply chaining the current wave generator code I have multiple times, and
            then adding the output of one generator (operator) to the position register of another generator.
            Thankfully, this doesn&#39;t require much extra math, but it does require some more complex coding to select
            operators and all that. I&#39;d also need to write some handling code on the Pico, especially for envelope
            control. Ideally, I&#39;d write a complete DX7 emulator on the Pico, which would let me be able to use it
            with anything that supports the ubiquitous synthesizer.</span></p>
    <p class="c0"><span class="c1">While waiting for the board to arrive, I also quickly added stereo capabilities by
            adding a relay that switches the output between center and left/right chip sets, where mono mode has 16
            centered channels while stereo mode divides the chips into two sides for 8 channels per ear. I haven&#39;t
            fabricated this version yet, but this version is the one currently available on GitHub. (To be able to make
            mono versions without a costly relay, I added jumper pads to be able to quickly bridge the board into forced
            mono mode.)</span></p>
    <p class="c0"><span class="c1">Finally, I&#39;ve been looking at whether I should try to sell assembled versions of
            the board. Now that it&#39;s a proper MIDI device, it&#39;s able to be used far beyond the niche of my
            little demo programs, and its extensibility (and low cost) could be a selling point for musicians with some
            programming knowledge who like to tinker with this stuff. The market for a chiptune PSG is probably pretty
            low, but adding analog synth-like functions and even a DX7 firmware could make it much more valuable to a
            wider audience. The price of parts for a single board (in batches of five) is about $45 USD, so I&#39;d
            probably sell the boards for $50-$60 each. I could probably reduce the price by using surface mount
            components too. I&#39;d have to do some more research as to how much demand there would be, but feel free to
            reach out to me if you&#39;d be interested if I ever decide to start selling them. (I also need a better
            name for the project - I&#39;m open to any and all suggestions!)</span></p>
    <p class="c0"><span class="c1">Unfortunately, I have much more limited free time nowadays, as I have classes that I
            have to focus on over all of this work; but I do hope to spend some time working on it a bit to stretch the
            board&#39;s potential. I&#39;ve really enjoyed working on this project so far, and I&#39;m glad to be able
            to recreate music so well using this little board I put together from a little idea I had in my head.</span>
    </p>
    <div>
        <p class="c14"><span class="c13"></span></p>
    </div>
</body>

</html>